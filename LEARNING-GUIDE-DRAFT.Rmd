---
title: 'Learning Guide Draft'
author: "Pippa,Rita,Jenny"
output: 
  html_document:
    keep_md: TRUE
    toc: TRUE
    toc_float: TRUE
    df_print: paged
    code_download: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error=TRUE, message=FALSE, warning=FALSE)
```

# Introduction
Leaflet is one of the most popular open-source JavaScript libraries for interactive maps. It’s used by websites ranging from The New York Times and The Washington Post to GitHub and Flickr, as well as GIS specialists like OpenStreetMap, Mapbox, and CartoDB.

This R package makes it easy to integrate and control Leaflet maps in R.

```{r}
library(tidyverse)     # for data cleaning and plotting
library(gplots)        # for col2hex() function
library(RColorBrewer)  # for color palettes
library(sf)            # for working with spatial data
library(leaflet)       # for highly customizable mapping
library(carData)       # for Minneapolis police stops data
library(tidytuesdayR)  # for bigfoot data 
library(ggthemes)      # for more themes (including theme_map())
library(htmltools)
theme_set(theme_minimal())
```

## Features
Interactive panning/zooming
  *Compose maps using arbitrary combinations of:
      ·Map tiles
      ·Markers
      ·Polygons
      ·Lines
      ·Popups
      ·GeoJSON
  *Create maps right from the R console or RStudio
  *Embed maps in knitr/R Markdown documents and Shiny apps
  *Easily render spatial objects from the sp or sf packages, or data frames with latitude/longitude columns
  *Use map bounds and mouse events to drive Shiny logic
  *Display maps in non spherical mercator projections
  *Augment map features using chosen plugins from leaflet plugins repository


# Basemaps

We are gonna start from the bottokm layer up. The first thing to look it is the basemaps. This means, what will be behind your points or shapes. There are many options and they are super easy to load in. 
We can start off with the basic basic map, simpple blue ocean and white land, if you zoom in there will be more detials

```{r}
leaflet() %>% 
  addTiles()
```

We can also start the map zoomed in on a specific area using latitude and longitude and the setView() function 

Here is Saint Paul MN, now look up your hometown and practice puting in the coordinates. 

```{r}
leaflet() %>% 
  addTiles() %>% 
  setView(lng = -93.093124, lat = 44.949642, zoom = 12)
  
```

```{r}
hometown <- leaflet() %>% 
  setView(lng = -93.093124, lat = 44.949642, zoom = 12) %>% 
    addTiles()
  
```

There are many other basemaps you can use in leaflet! 
To get different basemaps use the function addProviderTiles(), you will need to know the name of the basemap 
Here are some examples: 

```{r}
hometown %>% 
    addProviderTiles(providers$CartoDB.Positron)
```

```{r}
hometown %>% 
    addProviderTiles(providers$Stamen.Watercolor)
```

```{r}
hometown %>% 
    addProviderTiles(providers$CartoDB.DarkMatterNoLabels)
```

To get the full list of basemaps available through this function click here: http://leaflet-extras.github.io/leaflet-providers/preview/index.html 

Let say you really like the water color basemap but there arent any labels, you can layer base maps. Here I have layed the water color with the light grey basemap that had labels. As long as you set the one on top to have a lower opacity you can see both!  

```{r}
hometown %>% addProviderTiles(providers$Stamen.Watercolor) %>%
  addProviderTiles(providers$CartoDB.Positron,
    options = providerTileOptions(opacity = 0.5)) 
 
```

# Markers 

Now we have our basemap figured out whe can add markers. To do that we will needed data and the observation should have a latitude and longitdue variable to put them on the map. 

```{r}
tuesdata <- tidytuesdayR::tt_load('2022-09-13') #Loading in data from a tidy tuesday that has geographical points
bigfoot <- tuesdata$bigfoot
```

```{r}
leaflet(data = bigfoot) %>% addTiles() %>%
  addMarkers(~longitude, ~latitude)
```

If R is running slowly now its probably becuase there are so many data points. It is best to filter out observations that you need before making a map. 

```{r}
bigfootsub <- bigfoot %>% 
  filter(season == "Summer")
```

```{r}
leaflet(data = bigfootsub) %>% addTiles() %>%
  addMarkers(~longitude, ~latitude)
```
With less points the software runs far smoother. Now we can add some fun things! 

# Plain Markers and Popups
Not only can you add labels to these points but with leaflet you can add popups 
```{r}
leaflet(data = bigfootsub) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% #Changing basemap to something more neutral 
  addMarkers(~longitude, ~latitude,label = ~date, popup = ~location_details) # label means what will appear when you hover over the point and popup means what will appear when you click on a point
```

# Awesome Markers
Awesome markers allow you to change the color of the marker dependent on a variable 
```{r}
# After choosing temperature_high to be my variable I am visualizing I am going to filter out any observations that do not have a value for temperature_high
bftemp <- bigfootsub %>% 
  filter(temperature_high != "NA")
bftemp
```


```{r}

#Then we will need to assign values of temperature_high  to colors creating a getColor function 

getColor <- function(bftemp) {
  sapply(bftemp$temperature_high, function(temperature_high){
  if(temperature_high <= 68) { 
    "blue"
  } else if(temperature_high >= 69) {
    "red"
  } else {
    "green"
  } })
}

icons <- awesomeIcons(
  icon = 'ios-close',
  iconColor = 'pink', #Controls color of middle x 
  library = 'ion',
  markerColor = getColor(bftemp) #Calls the function 
)

leaflet(bftemp) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>% 
  addAwesomeMarkers(~longitude, ~latitude,label = ~date, popup = ~location_details, icon = icons) #make sure to set the icons
```
  
# Color

> Instead of using color as in the ggplot, we will use color palette for leaflet. In the palette, you call 1) the colors you want to use and 2) optionally, the range of inputs (i.e. domain) that are expected. The color function returns a palette function that can be passed a vector of input values, and it’ll return a vector of colors in #RRGGBB(AA) format.There are currently three color functions for dealing with continuous input: colorNumeric, colorBin, and colorQuantile; and one for categorical input, colorFactor.

```{r}
# load continuous dataset
data_site <- 
  "https://www.macalester.edu/~dshuman1/data/112/2014-Q4-Trips-History-Data.rds" 
Trips <- readRDS(gzcon(url(data_site)))
Stations<-read_csv("http://www.macalester.edu/~dshuman1/data/112/DC-Stations.csv")

departSta <- Trips %>%
  left_join(Stations, by = c("sstation" = "name")) %>%
  group_by(lat, long) %>%
  summarise(EventsCount = n())
```

## Create Color Palette

> domain arguement is optional, it tells the color function the range of input values( the specific variable you want to include).If you use a palette function multiple times across different data, it’s important to provide a non-NULL value for domain so the scaling between data and colors is consistent.

```{r}
# Call the color function (colorNumeric) to create a new palette function
pal <- colorNumeric(c("red", "green", "blue"), 1:10)
# Pass the palette function a data vector to get the corresponding colors
pal(c(1,6,9))
# create another color palette function with the range of inputs (i.e. domain) 
palDomain <- colorNumeric(
  palette = "Blues",
  domain = departSta$EventsCount)
# Show the corresponding colors
head(palDomain(departSta$EventsCount))
```

## Common parameters

```{r}
#RColorBrewer 
palBre <- colorNumeric(
  palette = "RdYlBu",
  domain = departSta$EventsCount)

#viridis
palVir <- colorNumeric(
  palette = "magma",
  domain = departSta$EventsCount)

#RGB or Named the colors: palette(), c("#000000", "#0000FF", "#FFFFFF"), topo.colors(10) etc

#A function that receives a single value between 0 and 1 and returns a color: colorRamp(c("#000000", "#FFFFFF"), interpolate="spline") etc
```

## Continuous data

```{r}
#Continuous input, continuous colors (colorNumeric)
palConC <- colorNumeric(
  palette = "RdYlBu",
  domain = departSta$EventsCount)

#Continuous input, discrete colors (colorBin and colorQuantile)

# colorBin:slicing the input domain up by value(bin)
palBin<-colorBin("Blues", departSta$EventsCount, 5, pretty = FALSE)

#colorQuantile: slicing the input domain into subsets with equal numbers of observations (by quantile)
palQuan <- colorQuantile("Blues", departSta$EventsCount, n = 7)
```


```{r example}
# colorBin
leaflet(data = departSta) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addProviderTiles(providers$Stamen.TonerLines,
                   options = providerTileOptions(opacity = 0.35)) %>%
  addProviderTiles(providers$Stamen.TonerLabels) %>%
    addCircles(lng = ~long,
             lat = ~lat,
            #stroke width in pixels
             weight = 10,
            #changes transparency, like alpha in ggplot
             opacity = 1,
             color = ~palBin(EventsCount))
# colorQuantile
leaflet(data = departSta) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addProviderTiles(providers$Stamen.TonerLines,
                   options = providerTileOptions(opacity = 0.35)) %>%
  addProviderTiles(providers$Stamen.TonerLabels) %>%
    addCircles(lng = ~long,
             lat = ~lat,
            #stroke width in pixels
             weight = 10,
            #changes transparency, like alpha in ggplot
             opacity = 1,
             color = ~palQuan(EventsCount))
```

## categorical data

> For categorical data, you will use the colorFactor function. If you want to specify the input domain, you can either by passing a factor or character vector to domain, or by providing levels directly using the levels parameter (in which case the domain will be ignored).

```{r}
#Domain
palFacD<-colorFactor(palette = "Blues", MplsStops$problem)
#Level
palFacL<-colorFactor(topo.colors(5),levels = MplsStops$problem)
```

```{r categorical example}
leaflet(data = MplsStops) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(lng = ~long,
             lat = ~lat,
             weight = 1,
             opacity = 1,
             stroke = TRUE,
             color = ~palFacL(problem))
```

# Lines and Shape

> For creating a rectangle, the four vector arguments indicating its four angles are required.While the Polygons and Polylines are more flexible and can be inferred from the data object.


```{r}
#rectangle
leaflet(data = departSta) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addProviderTiles(providers$Stamen.TonerLines,
                   options = providerTileOptions(opacity = 0.35)) %>%
  addProviderTiles(providers$Stamen.TonerLabels) %>%
  addCircles(
    lng = ~ long,
    lat = ~ lat,
    #stroke width in pixels
    weight = 10,
    #changes transparency, like alpha in ggplot
    opacity = 1,
    color = ~ palQuan(EventsCount)
  ) %>%
  addRectangles(
    lng1 = -77.20250,
    lat1 =38.80111,
    lng2 =-76.93186,
    lat2 = 39.12351,
    fillColor = "transparent"
  )

#Polygons and Polylines
leaflet(data = departSta) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addProviderTiles(providers$Stamen.TonerLines,
                   options = providerTileOptions(opacity = 0.35)) %>%
  addProviderTiles(providers$Stamen.TonerLabels) %>%
  addPolygons(
    lng = ~ long,
    lat = ~ lat,
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    # set the fill opacity
    fillOpacity = 0.6
  )
```

# Legend

> addLegend() function is aware of the different types of palette functions, and will create an appropriate default rendering for each type.Thus, you do not need to edit it manully when changing the domain or other scales.


```{r legend example}
leaflet(data = MplsStops) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(lng = ~long,
             lat = ~lat,
             weight = 1,
             opacity = 1,
             stroke = TRUE,
             color = ~palFacL(problem)) %>% 
    addLegend(position = "bottomleft", 
            pal = palFacL,
            values = ~problem,
             title = "Type of Stops") 
```


# Choropleth Map

```{r}
states <- geojsonio::geojson_read("https://rstudio.github.io/leaflet/json/us-states.geojson", what = "sp")

bins <- c(0, 10, 20, 50, 100, 200, 500, 1000, Inf)
pal <- colorBin("YlOrRd", domain = states$density, bins = bins)

labels <- sprintf(
  "<strong>%s</strong><br/>%g people / mi<sup>2</sup>",
  states$name, states$density
) %>% lapply(htmltools::HTML)

leaflet(states) %>%
  setView(-96, 37.8, 4) %>%
  addProviderTiles("MapBox", options = providerTileOptions(
    id = "mapbox.light",
    accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN'))) %>% 
  addPolygons(
    fillColor = ~pal(density),
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    # hightlight the polygon when curse over it
    highlightOptions = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE),
    # add labels
    label = labels,
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"))
```
