---
title: 'Learning Guide Draft'
author: "Pippa,Rita,Jenny"
output: 
  html_document:
    keep_md: TRUE
    toc: TRUE
    toc_float: TRUE
    df_print: paged
    code_download: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error=TRUE, message=FALSE, warning=FALSE)
```


```{r}
library(tidyverse)     # for data cleaning and plotting
library(gplots)        # for col2hex() function
library(RColorBrewer)  # for color palettes
library(sf)            # for working with spatial data
library(leaflet)       # for highly customizable mapping
library(carData)       # for Minneapolis police stops data
library(ggthemes)      # for more themes (including theme_map())
library(htmltools)
theme_set(theme_minimal())
```
# Introduction
Leaflet is one of the most popular open-source JavaScript libraries for interactive maps. It’s used by websites ranging from The New York Times and The Washington Post to GitHub and Flickr, as well as GIS specialists like OpenStreetMap, Mapbox, and CartoDB.

This R package makes it easy to integrate and control Leaflet maps in R.

## Features
Interactive panning/zooming
*Compose maps using arbitrary combinations of:
·Map tiles
·Markers
·Polygons
·Lines
·Popups
·GeoJSON
*Create maps right from the R console or RStudio
*Embed maps in knitr/R Markdown documents and Shiny apps
*Easily render spatial objects from the sp or sf packages, or data frames with latitude/longitude columns
*Use map bounds and mouse events to drive Shiny logic
*Display maps in non spherical mercator projections
*Augment map features using chosen plugins from leaflet plugins repository

# Color

> Instead of using color as in the ggplot, we will use color palette for leaflet. In the palette, you call 1) the colors you want to use and 2) optionally, the range of inputs (i.e. domain) that are expected. The color function returns a palette function that can be passed a vector of input values, and it’ll return a vector of colors in #RRGGBB(AA) format.
There are currently three color functions for dealing with continuous input: colorNumeric, colorBin, and colorQuantile; and one for categorical input, colorFactor.

```{r}
# load continuous dataset
data_site <- 
  "https://www.macalester.edu/~dshuman1/data/112/2014-Q4-Trips-History-Data.rds" 
Trips <- readRDS(gzcon(url(data_site)))
Stations<-read_csv("http://www.macalester.edu/~dshuman1/data/112/DC-Stations.csv")

departSta <- Trips %>%
  left_join(Stations, by = c("sstation" = "name")) %>%
  group_by(lat, long) %>%
  summarise(EventsCount = n())
```

## Create Color Palette

> domain arguement is optional, it tells the color function the range of input values( the specific variable you want to include).If you use a palette function multiple times across different data, it’s important to provide a non-NULL value for domain so the scaling between data and colors is consistent.

```{r}
# Call the color function (colorNumeric) to create a new palette function
pal <- colorNumeric(c("red", "green", "blue"), 1:10)
# Pass the palette function a data vector to get the corresponding colors
pal(c(1,6,9))
# create another color palette function with the range of inputs (i.e. domain) 
palDomain <- colorNumeric(
  palette = "Blues",
  domain = departSta$EventsCount)
# Show the corresponding colors
head(palDomain(departSta$EventsCount))
```

## Common parameters

```{r}
#RColorBrewer 
palBre <- colorNumeric(
  palette = "RdYlBu",
  domain = departSta$EventsCount)

#viridis
palVir <- colorNumeric(
  palette = "magma",
  domain = departSta$EventsCount)

#RGB or Named the colors: palette(), c("#000000", "#0000FF", "#FFFFFF"), topo.colors(10) etc

#A function that receives a single value between 0 and 1 and returns a color: colorRamp(c("#000000", "#FFFFFF"), interpolate="spline") etc
```

## Continuous data

```{r}
#Continuous input, continuous colors (colorNumeric)
palConC <- colorNumeric(
  palette = "RdYlBu",
  domain = departSta$EventsCount)

#Continuous input, discrete colors (colorBin and colorQuantile)

# colorBin:slicing the input domain up by value(bin)
palBin<-colorBin("Blues", departSta$EventsCount, 5, pretty = FALSE)

#colorQuantile: slicing the input domain into subsets with equal numbers of observations (by quantile)
palQuan <- colorQuantile("Blues", departSta$EventsCount, n = 7)
```


```{r example}
# colorBin
leaflet(data = departSta) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addProviderTiles(providers$Stamen.TonerLines,
                   options = providerTileOptions(opacity = 0.35)) %>%
  addProviderTiles(providers$Stamen.TonerLabels) %>%
    addCircles(lng = ~long,
             lat = ~lat,
            #stroke width in pixels
             weight = 10,
            #changes transparency, like alpha in ggplot
             opacity = 1,
             color = ~palBin(EventsCount))

# colorQuantile
leaflet(data = departSta) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addProviderTiles(providers$Stamen.TonerLines,
                   options = providerTileOptions(opacity = 0.35)) %>%
  addProviderTiles(providers$Stamen.TonerLabels) %>%
    addCircles(lng = ~long,
             lat = ~lat,
            #stroke width in pixels
             weight = 10,
            #changes transparency, like alpha in ggplot
             opacity = 1,
             color = ~palQuan(EventsCount))
```

## categorical data

> For categorical data, you will use the colorFactor function. If you want to specify the input domain, you can either by passing a factor or character vector to domain, or by providing levels directly using the levels parameter (in which case the domain will be ignored).

```{r}
#Domain
palFacD<-colorFactor(palette = "Blues", MplsStops$problem)
#Level
palFacL<-colorFactor(topo.colors(5),levels = MplsStops$problem)
```

```{r example}
leaflet(data = MplsStops) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(lng = ~long,
             lat = ~lat,
             weight = 1,
             opacity = 1,
             stroke = TRUE,
             color = ~palFacL(problem))
```

# Lines and Shape

> For creating a rectangle, the four vector arguments indicating its four angles are required.While the Polygons and Polylines are more flexible and can be inferred from the data object.

```{r}
#rectangle
leaflet(data = departSta) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addProviderTiles(providers$Stamen.TonerLines,
                   options = providerTileOptions(opacity = 0.35)) %>%
  addProviderTiles(providers$Stamen.TonerLabels) %>%
  addCircles(
    lng = ~ long,
    lat = ~ lat,
    #stroke width in pixels
    weight = 10,
    #changes transparency, like alpha in ggplot
    opacity = 1,
    color = ~ palQuan(EventsCount)
  ) %>%
  addRectangles(
    lng1 = -77.20250,
    lat1 =38.80111,
    lng2 =-76.93186,
    lat2 = 39.12351,
    fillColor = "transparent"
  )

#Polygons and Polylines
leaflet(data = departSta) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addProviderTiles(providers$Stamen.TonerLines,
                   options = providerTileOptions(opacity = 0.35)) %>%
  addProviderTiles(providers$Stamen.TonerLabels) %>%
  addPolygons(
    lng = ~ long,
    lat = ~ lat,
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    # set the fill opacity
    fillOpacity = 0.6
  )
```

# Legend

> addLegend() function is aware of the different types of palette functions, and will create an appropriate default rendering for each type.Thus, you do not need to edit it manully when changing the domain or other scales.

```{r example}
leaflet(data = MplsStops) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(lng = ~long,
             lat = ~lat,
             weight = 1,
             opacity = 1,
             stroke = TRUE,
             color = ~palFacL(problem)) %>% 
    addLegend(position = "bottomleft", 
            pal = palFacL,
            values = ~problem,
             title = "Type of Stops") 
```

